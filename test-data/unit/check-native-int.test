[case testNativeIntBasics]
from mypy_extensions import i32, i64

def f(x: int) -> i32:
    return i32(x)

reveal_type(i32(1) + i32(2))  # N: Revealed type is "mypy_extensions.i32"
i32(1) + i64(2)  # E: Unsupported operand types for + ("i32" and "i64")
[builtins fixtures/dict.pyi]

[case testNativeIntCoercions]
from mypy_extensions import i32, i64

a: i32 = 1
b: i64 = 2
c: i64 = a  # E: Incompatible types in assignment (expression has type "i32", variable has type "i64")
d: i64 = i64(a)
e: i32 = b  # E: Incompatible types in assignment (expression has type "i64", variable has type "i32")
f: i32 = i32(b)
g: int = a
h: int = b
[builtins fixtures/dict.pyi]

[case testNativeIntJoins]
from typing import TypeVar
from mypy_extensions import i32, i64

T = TypeVar('T')

def join(x: T, y: T) -> T: return x

n32: i32 = 0
n64: i64 = 1
n = 2

reveal_type(join(n32, n))  # N: Revealed type is "mypy_extensions.i32"
reveal_type(join(n, n32))  # N: Revealed type is "mypy_extensions.i32"
reveal_type(join(n64, n))  # N: Revealed type is "mypy_extensions.i64"
reveal_type(join(n, n64))  # N: Revealed type is "mypy_extensions.i64"
# i32 and i64 aren't treated as compatible
reveal_type(join(n32, n64))  # N: Revealed type is "builtins.object"
reveal_type(join(n64, n32))  # N: Revealed type is "builtins.object"
[builtins fixtures/dict.pyi]

[case testNativeIntMeets]
# flags: --strict-optional
from typing import TypeVar, Callable
from mypy_extensions import i32, i64

T = TypeVar('T')

def f32(x: i32) -> None: pass
def f64(x: i64) -> None: pass
def f(x: int) -> None: pass

def meet(c1: Callable[[T], None], c2: Callable[[T], None]) -> T:
    pass

reveal_type(meet(f32, f))  # N: Revealed type is "builtins.int"
reveal_type(meet(f, f32))  # N: Revealed type is "builtins.int"
reveal_type(meet(f64, f))  # N: Revealed type is "builtins.int"
reveal_type(meet(f, f64))  # N: Revealed type is "builtins.int"
reveal_type(meet(f32, f64))  # N: Revealed type is "builtins.int"
reveal_type(meet(f64, f32))  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testNativeIntCoerceInArithmetic]
from mypy_extensions import i32

reveal_type(i32(1) + 1)  # N: Revealed type is "mypy_extensions.i32"
reveal_type(1 + i32(1))  # N: Revealed type is "mypy_extensions.i32"
[builtins fixtures/dict.pyi]

[case testNativeIntNoNarrowing]
from mypy_extensions import i32

x: i32 = 1
if int():
    x = 2
    reveal_type(x)  # N: Revealed type is "mypy_extensions.i32"
reveal_type(x)  # N: Revealed type is "mypy_extensions.i32"

y = 1
if int():
    y = i32(1)
    reveal_type(y)  # N: Revealed type is "builtins.int"
reveal_type(y)  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testNativeIntFloatConversion]
from mypy_extensions import i32

x: i32 = 1.1  # E: Incompatible types in assignment (expression has type "float", variable has type "i32")
y: float = i32(1)  # E: Incompatible types in assignment (expression has type "i32", variable has type "float")
[builtins fixtures/dict.pyi]
